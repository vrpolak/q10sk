# TODO: Add formatting.

Few notes.

No specific code for end of program, instead the backtick symbol
acts as such when there is not enough items to combine.

Implementing integers is much more work than needed.
Instead, stack also contains "backtick implementations",
the deepest one starting the program.

Supporting empty programs makes the loader more complicated,
but also makes the serialized programs less surprising.

Two main stack layout possibilities, depending on whether
"backtick as run" is deeper than the first node.
To support empty programs, it is better if it is.

Deserialization has two phases. Backtick detection and leaf deserialization.

Loader program has to contain both backtick implementations,
so it is easier to have "run" at the bottom of the stack,
and pass "combine" as an argument.
Every time a leaf is deselialized,
the combine backtick implementation is then added to the stack.
From bottom of stack: backtick_run, fist_item, backtick_combine, second item, ...

For leaf encoding, a less than obvious schema is used
(the benefit will be visible later):
' = 0
K = 11
S = 100
Q = 1010
0 = 10110
1 = 10111

Leaf decoder (without continuation): {``Q(a)[b]}
{``Q({``Q(S)[{``Q(Q)[{``Q(0)[1]}]]})[K]}
With continuation:
`Lc = {``Q({``Q(`cS)[{``Q(`cQ)[{``Q(`c0)[`c1]}]]})[`cK]}
`Lc = ``Q``Q`cS``Q`cQ``Q`c0`c1`cK
`Lc = ``Q``Q`cS``Q`cQ``Q`c0`c1`cK
L = ``S``S`KQ``S``S`KQ``S``SKK`KS``S``S`KQ``S``SKK`KQ``S``S`KQ``S``SKK`K0``S``SKK`K1``S``SKK`KK
This assumes c contains backtick_combine implementation.

It is better to have the next loop only towards the top of the stack.
In that case, Backtick implementation caller is:
(remember there should always be i/j between `ab and `nn,
 but we allow no impl between `jn and a)
`````Cnkajb = ````jnajb
````Cnkaj = ```jnaj
C = ``S`KK``S``S`KS``S`K`S`KS``S``S`KS``S`KK``S`KS``S`K`S``SKKK`KK`K`SK

Inner implementation of apply (where M is a main loop) is `im:
M = `mm
````inajb = ```nnj`ab
i = ``S``S`KS``S`KK``S`KS``S`K`S`KS``S`K`S`KK``S``SKK``SKK`KK

So main loop:
````mnkaj = `````Q`Cn`L``nnikaj
````mnkaj = `````Q`Cn`L````S``SKK``SKKnikaj
`mn = ``Q`Cn`L``nni
`mn = ``Q`Cn`L````S``SKK``SKKni
m = ``S``S`KQC``S`KL``S``S``SKK``SKK`Ki
Substitute...
m = ``S``S`KQC``S`KL``S``S``SKK``SKK`K``S``S`KS``S`KK``S`KS``S`K`S`KS``S`K`S`KK``S``SKK``SKK`KK
m = ``S``S`KQC``S`K``S``S`KQ``S``S`KQ``S``SKK`KS``S``S`KQ``S``SKK`KQ``S``S`KQ``S``SKK`K0``S``SKK`K1``S``SKK`KK``S``S``SKK``SKK`K``S``S`KS``S`KK``S`KS``S`K`S`KS``S`K`S`KK``S``SKK``SKK`KK
m = ``S``S`KQ``S`KK``S``S`KS``S`K`S`KS``S``S`KS``S`KK``S`KS``S`K`S``SKKK`KK`K`SK``S`K``S``S`KQ``S``S`KQ``S``SKK`KS``S``S`KQ``S``SKK`KQ``S``S`KQ``S``SKK`K0``S``SKK`K1``S``SKK`KK``S``S``SKK``SKK`K``S``S`KS``S`KK``S`KS``S`K`S`KS``S`K`S`KK``S``SKK``SKK`KK

Now, runner (bottom item, "j" so far) needs to be:
``rna = a
r = `SK

The initial state as a "SK" program:
p = `Mr = ````SIImr = ````S``SKK``SKKmr = ````S``SKK``SKKm`SK
p = ````S``SKK``SKK``S``S`KQC``S`KL``S``S``SKK``SKK`Ki`SK
p = ````S``SKK``SKK``S``S`KQC``S`KL``S``S``SKK``SKK`K``S`KS``S`KK``S``SKK``SKK`SK
p = ````S``SKK``SKK``S``S`KQ``S`KK``S``S`KS``S`KK``S`KS``S`K`S``SKKK`KK``S`K``S``S`KQ``S``S`KQ``S``SKK`KS``S``S`KQ``S``SKK`KQ``S``S`KQ``S``SKK`K0``S``SKK`K1``S``SKK`KK``S``S``SKK``SKK`K``S`KS``S`KK``S``SKK``SKK`SK

Now, header considerations. As multiple encodings are possible, we want to include the loader program to show which encoding is used.
But it could be unclear where the loader ends, so we prepend loader twice.
For that to correctly specify the loader, its encoding should not contain two repeated segments at the start.
As our loader loads from argument side, current code with `SK does not work,
and it will not easily work with any "one-bit `, two-bit K" scheme.
We can cheat by realizing `SK is `KI and using ``SKS instead of ``SKK for I:
R := `KI = `K``SKS
``Rna = ``(`K``SKS)na = `(``K ``SKS n)a = `(``SKS)a = ``Ka`Sa = a
As our loader loads from argument side, current code with ``SKK would not work.
In the straigthforward encodng scheme, code for S would be 110 which repeats 1.
And that explains why we flipped that bit to encode S as 100.
P = `MR = ````S``SKK``SKKm`K``SKS
P = ````S``SKK``SKKm`K``SKS
P = ````S``SKK``SKK``S``S`KQ``S`KK``S``S`KS``S`K`S`KS``S``S`KS``S`KK``S`KS``S`K`S``SKKK`KK`K`SK``S`K``S``S`KQ``S``S`KQ``S``SKK`KS``S``S`KQ``S``SKK`KQ``S``S`KQ``S``SKK`K0``S``SKK`K1``S``SKK`KK``S``S``SKK``SKK`K``S``S`KS``S`KK``S`KS``S`K`S`KS``S`K`S`KK``S``SKK``SKK`KK`K``SKS

SKS program:
P = ````S``SKK``SKK``S``S`KQ``S`KK``S``S`KS``S`KK``S`KS``S`K`S``SKKK`KK``S`K``S``S`KQ``S``S`KQ``S``SKK`KS``S``S`KQ``S``SKK`KQ``S``S`KQ``S``SKK`K0``S``SKK`K1``S``SKK`KK``S``S``SKK``SKK`K``S`KS``S`KK``S``SKK``SKK`K``SKS
Serialized (single copy):
1001110000110111101111100001111100001000011110100011010000100110100011010000100110100001111010000100110100001000011011111000011111000010000100001111011111000010000101111101111100001000010110110111110000100001010110100001000010101101111100001000010101101000010000100110111110000100001010110100001000010101101000010000110100001110001101111011111110000100011010000100110100001111010000100110100001000010011010001101000010011010000100001111010000101011010000100001111100001111100001000000
(484 bits, fits into 61 bytes, two copies into 121.)

As expected, ``SKS from the end never repeats in reasonable programs, but "10011100" of course can appear in binary imput of the said program.
The loader does not even contain another copy of "100111".

# TODO: Turn all of the above into a coherent text document.

# TODO: Add tests to confirm the loader works as intended.
